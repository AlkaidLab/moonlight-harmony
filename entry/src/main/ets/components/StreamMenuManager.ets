/*
 * Moonlight for HarmonyOS
 * Copyright (C) 2024-2025 Moonlight/AlkaidLab
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

/**
 * ä¸²æµèœå•ç®¡ç†å™¨
 * 
 * è´Ÿè´£ç®¡ç†ä¸²æµé¡µé¢çš„èœå•é…ç½®å’Œä¸šåŠ¡é€»è¾‘
 * ä¸ Android GameMenu åŠŸèƒ½å¯¹é½
 */
import { promptAction } from '@kit.ArkUI';
import { StreamingSession } from '../service/StreamingSession';
import { StreamViewModel, TouchMode } from '../viewmodel/StreamViewModel';
import { OptionPickerDialogConfig, OptionItem } from './OptionPickerDialog';

/**
 * Windows è™šæ‹Ÿé”®ç å®šä¹‰
 */
export class VirtualKey {
  static readonly VK_ESCAPE = 0x1B;
  static readonly VK_LWIN = 0x5B;
  static readonly VK_MENU = 0x12;      // Alt
  static readonly VK_CONTROL = 0x11;
  static readonly VK_SHIFT = 0x10;
  static readonly VK_TAB = 0x09;
  static readonly VK_DELETE = 0x2E;
  static readonly VK_B = 0x42;
  static readonly VK_F4 = 0x73;
  static readonly VK_L = 0x4C;
  static readonly VK_N = 0x4E;
  static readonly VK_O = 0x4F;
  static readonly VK_X = 0x58;
  static readonly VK_U = 0x55;
  static readonly VK_S = 0x53;
}

/**
 * èœå•æ“ä½œå›è°ƒ
 */
export interface StreamMenuCallbacks {
  onResume: () => void;
  onDisconnect: () => void;
  onQuitGame: () => void;
  onTouchModeChanged: (mode: string) => void;
  onShowTouchModeMenu: () => void;
}

/**
 * ä¸²æµèœå•ç®¡ç†å™¨
 */
export class StreamMenuManager {
  private viewModel: StreamViewModel;
  private callbacks: StreamMenuCallbacks;

  constructor(viewModel: StreamViewModel, callbacks: StreamMenuCallbacks) {
    this.viewModel = viewModel;
    this.callbacks = callbacks;
  }

  /**
   * è·å–ä¸²æµä¼šè¯
   */
  private getSession(): StreamingSession | null {
    return this.viewModel.getSession();
  }

  /**
   * æ˜¾ç¤º Toast æç¤º
   */
  private showToast(message: string): void {
    try {
      promptAction.showToast({
        message: message,
        duration: 1500
      });
    } catch (e) {
      console.warn('showToast failed:', e);
    }
  }

  /**
   * è·å–è§¦æ‘¸æ¨¡å¼çš„ä¸­æ–‡åç§°
   */
  getTouchModeName(): string {
    switch (this.viewModel.touchMode) {
      case 'trackpad':
        return 'è§¦æ‘¸æ¿æ¨¡å¼';
      case 'direct':
        return 'ç›´æ¥è§¦æ‘¸æ¨¡å¼';
      case 'mouse':
        return 'é¼ æ ‡æ¨¡å¼';
      default:
        return this.viewModel.touchMode;
    }
  }

  /**
   * è·å–æ€§èƒ½è¦†ç›–å±‚çŠ¶æ€æè¿°
   */
  getPerformanceOverlayStatus(): string {
    if (!this.viewModel.showOverlay) {
      return 'å½“å‰: å…³é—­';
    } else if (this.viewModel.overlayState.config.isLocked) {
      return 'å½“å‰: å›ºå®šæ˜¾ç¤º';
    } else {
      return 'å½“å‰: æ‚¬æµ®æ˜¾ç¤º';
    }
  }

  /**
   * è·å–ä¸»ä¸²æµèœå•é…ç½®
   */
  getStreamMenuConfig(): OptionPickerDialogConfig {
    const options: OptionItem[] = [
      {
        title: 'ğŸ® ç»§ç»­æ¸¸æˆ',
        subtitle: 'å…³é—­æ­¤èœå•ï¼Œç»§ç»­ä¸²æµ',
        value: 'resume'
      },
      {
        title: 'â‹ å‘é€ ESC',
        subtitle: 'å‘è¿œç¨‹å‘é€ ESC é”®',
        value: 'send_esc'
      },
      {
        title: 'âŠ å‘é€ Win',
        subtitle: 'æ‰“å¼€/å…³é—­ Windows å¼€å§‹èœå•',
        value: 'send_win'
      },
      {
        title: 'ğŸŒˆ åˆ‡æ¢ HDR',
        subtitle: 'å‘é€ Win+Alt+B åˆ‡æ¢ HDR',
        value: 'toggle_hdr'
      },
      {
        title: 'âŒ¨ï¸ æ‰“å¼€ä¸»æœºé”®ç›˜',
        subtitle: 'å‘é€ Win+Ctrl+O å‘¼å‡ºç³»ç»Ÿé”®ç›˜',
        value: 'host_keyboard'
      },
      {
        title: `ğŸ‘† åˆ‡æ¢è§¦æ‘¸æ¨¡å¼`,
        subtitle: `å½“å‰: ${this.getTouchModeName()}`,
        value: 'touch_mode'
      },
      {
        title: this.viewModel.showOverlay ? 'ğŸ“Š éšè—æ€§èƒ½ç›‘æ§' : 'ğŸ“Š æ˜¾ç¤ºæ€§èƒ½ç›‘æ§',
        subtitle: this.getPerformanceOverlayStatus(),
        value: 'toggle_overlay'
      },
      {
        title: this.viewModel.showController ? 'ğŸ® éšè—è™šæ‹ŸæŒ‰é”®' : 'ğŸ® æ˜¾ç¤ºè™šæ‹ŸæŒ‰é”®',
        subtitle: 'åˆ‡æ¢å±å¹•è™šæ‹Ÿæ§åˆ¶å™¨',
        value: 'toggle_controller'
      },
      {
        title: 'ğŸ”Œ æ–­å¼€è¿æ¥',
        subtitle: 'ç»“æŸä¸²æµä½†ä¿æŒæ¸¸æˆè¿è¡Œ',
        value: 'disconnect'
      },
      {
        title: 'ğŸšª é€€å‡ºæ¸¸æˆ',
        subtitle: 'å…³é—­è¿œç¨‹æ¸¸æˆå¹¶è¿”å›',
        value: 'quit_game'
      }
    ];

    return {
      title: 'ğŸ¥ ä¸²æµèœå•',
      subtitle: 'æŒ‰è¿”å›é”®å¯å†æ¬¡æ‰“å¼€æ­¤èœå•',
      options: options,
      selectedValue: '',
      onSelect: (option: OptionItem) => {
        this.handleMainMenuSelect(option);
      }
    };
  }

  /**
   * å¤„ç†ä¸»èœå•é€‰æ‹©
   */
  private handleMainMenuSelect(option: OptionItem): void {
    const session = this.getSession();

    switch (option.value) {
      case 'resume':
        this.callbacks.onResume();
        break;
      case 'send_esc':
        session?.sendKeys([VirtualKey.VK_ESCAPE]);
        this.showToast('å·²å‘é€ ESC');
        break;
      case 'send_win':
        session?.sendKeys([VirtualKey.VK_LWIN]);
        this.showToast('å·²å‘é€ Win');
        break;
      case 'toggle_hdr':
        session?.sendKeys([VirtualKey.VK_LWIN, VirtualKey.VK_MENU, VirtualKey.VK_B]);
        this.showToast('å·²å‘é€ Win+Alt+B');
        break;
      case 'host_keyboard':
        session?.sendKeys([VirtualKey.VK_LWIN, VirtualKey.VK_CONTROL, VirtualKey.VK_O]);
        this.showToast('å·²å‘é€ Win+Ctrl+O');
        break;
      case 'touch_mode':
        this.callbacks.onShowTouchModeMenu();
        break;
      case 'toggle_overlay':
        this.viewModel.toggleOverlay();
        break;
      case 'toggle_controller':
        this.viewModel.toggleController();
        break;
      case 'disconnect':
        this.callbacks.onDisconnect();
        break;
      case 'quit_game':
        this.callbacks.onQuitGame();
        break;
    }
  }

  /**
   * è·å–è§¦æ‘¸æ¨¡å¼å­èœå•é…ç½®
   */
  getTouchModeMenuConfig(): OptionPickerDialogConfig {
    const currentMode = this.viewModel.touchMode;

    const options: OptionItem[] = [
      {
        title: currentMode === 'trackpad' ? 'âœ“ è§¦æ‘¸æ¿æ¨¡å¼' : '  è§¦æ‘¸æ¿æ¨¡å¼',
        subtitle: 'ç›¸å¯¹ç§»åŠ¨ï¼Œåƒä½¿ç”¨ç¬”è®°æœ¬è§¦æ‘¸æ¿',
        value: 'trackpad'
      },
      {
        title: currentMode === 'direct' ? 'âœ“ ç›´æ¥è§¦æ‘¸æ¨¡å¼' : '  ç›´æ¥è§¦æ‘¸æ¨¡å¼',
        subtitle: 'ç»å¯¹åæ ‡ï¼Œç‚¹å“ªç§»å“ª',
        value: 'direct'
      },
      {
        title: currentMode === 'mouse' ? 'âœ“ é¼ æ ‡æ¨¡å¼' : '  é¼ æ ‡æ¨¡å¼',
        subtitle: 'ç›¸å¯¹ç§»åŠ¨ + æŒ‰ä½æ‹–åŠ¨',
        value: 'mouse'
      },
      {
        title: 'ğŸ–±ï¸ åˆ‡æ¢è¿œç¨‹é¼ æ ‡æŒ‡é’ˆ',
        subtitle: 'å‘é€ Ctrl+Alt+Shift+N åˆ‡æ¢é¼ æ ‡',
        value: 'toggle_remote_mouse'
      }
    ];

    return {
      title: 'ğŸ‘† é€‰æ‹©è§¦æ‘¸æ¨¡å¼',
      subtitle: `å½“å‰: ${this.getTouchModeName()}`,
      options: options,
      selectedValue: this.viewModel.touchMode,
      onSelect: (option: OptionItem) => {
        this.handleTouchModeSelect(option);
      }
    };
  }

  /**
   * å¤„ç†è§¦æ‘¸æ¨¡å¼é€‰æ‹©
   */
  private handleTouchModeSelect(option: OptionItem): void {
    if (option.value === 'toggle_remote_mouse') {
      const session = this.getSession();
      session?.sendKeys([VirtualKey.VK_CONTROL, VirtualKey.VK_MENU, VirtualKey.VK_SHIFT, VirtualKey.VK_N]);
      this.showToast('å·²å‘é€åˆ‡æ¢è¿œç¨‹é¼ æ ‡æŒ‡é’ˆ');
    } else {
      this.callbacks.onTouchModeChanged(option.value as string);
      this.showToast(`å·²åˆ‡æ¢åˆ°${this.getTouchModeName()}`);
    }
  }
}
