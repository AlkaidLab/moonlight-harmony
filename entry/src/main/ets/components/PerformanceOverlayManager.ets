/*
 * Moonlight for HarmonyOS
 * Copyright (C) 2024-2025 Moonlight/AlkaidLab
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

/**
 * æ€§èƒ½è¦†ç›–å±‚ç®¡ç†å™¨
 * ä¸ Android ç‰ˆæœ¬å¯¹é½ï¼Œæ”¯æŒï¼š
 * - å¯æ‹–åŠ¨ï¼ˆ8ä¸ªé¢„è®¾ä½ç½®å¸é™„ï¼‰
 * - å¯ç‚¹å‡»ï¼ˆæ˜¾ç¤ºé¡¹ç›®è¯¦æƒ…ï¼‰
 * - åŒå‡»åˆ‡æ¢å¸ƒå±€
 * - é¡¹ç›®å¯é€‰
 * - é”å®šæ¨¡å¼
 */

import { promptAction } from '@kit.ArkUI';

// æ€§èƒ½é¡¹ç›®å›¾æ ‡å¸¸é‡ç±» - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ emoji å›¾æ ‡
export class PerfIcons {
  static readonly RESOLUTION: string = 'ğŸ“±';      // åˆ†è¾¨ç‡
  static readonly DECODER: string = 'ğŸ¬';         // è§£ç å™¨
  static readonly FPS: string = 'ğŸ®';             // å¸§ç‡ï¼ˆä¸å†ä½¿ç”¨ï¼Œä¿ç•™å…¼å®¹ï¼‰
  static readonly PACKET_LOSS: string = 'ğŸ“¶';     // ä¸¢åŒ…ç‡/ç½‘ç»œä¿¡å·
  static readonly BITRATE: string = 'â³';         // å¸¦å®½/ä¼ è¾“
  static readonly NETWORK: string = 'ğŸŒ';         // ç½‘ç»œå»¶è¿Ÿ
  static readonly DECODE_NORMAL: string = 'â±ï¸';   // è§£ç å»¶è¿Ÿï¼ˆæ­£å¸¸ï¼‰
  static readonly DECODE_HOT: string = 'ğŸ¥µ';      // è§£ç å»¶è¿Ÿï¼ˆè¿‡çƒ­ï¼‰
  static readonly HOST: string = 'ğŸ–¥ï¸';            // ä¸»æœºå»¶è¿Ÿ
  static readonly BATTERY: string = 'ğŸ”‹';         // ç”µæ± 
  static readonly CHARGING: string = 'âš¡';        // å……ç”µä¸­
}

// æ€§èƒ½é¡¹ç›®åç§°å¸¸é‡ç±» - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰æ˜¾ç¤ºåç§°
export class PerfLabels {
  static readonly RESOLUTION: string = 'åˆ†è¾¨ç‡';
  static readonly DECODER: string = 'è§£ç å™¨';
  static readonly FPS: string = 'å¸§ç‡';
  static readonly PACKET_LOSS: string = 'ä¸¢åŒ…ç‡';
  static readonly BITRATE: string = 'å¸¦å®½';
  static readonly NETWORK: string = 'ç½‘ç»œçŠ¶æ€';
  static readonly DECODE: string = 'è§£ç å»¶è¿Ÿ';
  static readonly HOST: string = 'ä¸»æœºå»¶è¿Ÿ';
  static readonly BATTERY: string = 'ç”µæ± ';
}

// æ€§èƒ½é¡¹ç›®æšä¸¾
export enum PerformanceItem {
  RESOLUTION = 'resolution',
  DECODER = 'decoder',
  RENDER_FPS = 'render_fps',
  PACKET_LOSS = 'packet_loss',
  BITRATE = 'bitrate',          // ç ç‡
  NETWORK_LATENCY = 'network_latency',  // ç½‘ç»œå»¶è¿Ÿï¼ˆRTTï¼‰
  DECODE_LATENCY = 'decode_latency',
  HOST_LATENCY = 'host_latency',
  BATTERY = 'battery'
}

// å¸é™„ä½ç½®æšä¸¾
export enum SnapPosition {
  TOP_LEFT = 'top_left',
  TOP_CENTER = 'top_center',
  TOP_RIGHT = 'top_right',
  CENTER_LEFT = 'center_left',
  CENTER_RIGHT = 'center_right',
  BOTTOM_LEFT = 'bottom_left',
  BOTTOM_CENTER = 'bottom_center',
  BOTTOM_RIGHT = 'bottom_right'
}

// æ€§èƒ½æ•°æ®ç±»
export class PerformanceData {
  streamWidth: number = 0;
  streamHeight: number = 0;
  targetFps: number = 0;
  receivedFps: number = 0;
  renderedFps: number = 0;
  codec: string = '';
  isHdr: boolean = false;
  packetLoss: number = 0;
  bitrate: number = 0;
  decodeLatency: number = 0;
  networkLatency: number = 0;
  hostLatency: number = 0;
  batteryLevel: number = 100;
  isCharging: boolean = false;
}

// è¦†ç›–å±‚é…ç½®ç±»
export class OverlayConfig {
  isVertical: boolean = true;          // æ˜¯å¦å‚ç›´å¸ƒå±€
  isLocked: boolean = false;           // æ˜¯å¦é”å®šï¼ˆä¸å¯æ‹–åŠ¨ï¼‰
  position: SnapPosition = SnapPosition.TOP_RIGHT;  // å½“å‰ä½ç½®ï¼ˆé»˜è®¤å³ä¸Šè§’ï¼‰
  enabledItems: Set<string> = new Set<string>();   // å¯ç”¨çš„é¡¹ç›®ï¼ˆä½¿ç”¨ string ç±»å‹ï¼‰
  customX: number = 0;                 // è‡ªå®šä¹‰Xåæ ‡
  customY: number = 0;                 // è‡ªå®šä¹‰Yåæ ‡
}

// æ€§èƒ½é¡¹ç›®ä¿¡æ¯ç±»
export class PerformanceItemInfo {
  title: string;
  description: string;
  
  constructor(title: string, description: string) {
    this.title = title;
    this.description = description;
  }
}

// åæ ‡ç±»
export class Position {
  x: number;
  y: number;
  
  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

// é»˜è®¤é…ç½®
export function getDefaultOverlayConfig(): OverlayConfig {
  const config = new OverlayConfig();
  config.isVertical = true;   // é»˜è®¤ç«–å‘å¸ƒå±€
  config.isLocked = false;
  config.position = SnapPosition.TOP_RIGHT;  // é»˜è®¤å³ä¸Šè§’
  config.enabledItems = new Set<string>([
    PerformanceItem.RESOLUTION,
    PerformanceItem.DECODER,
    PerformanceItem.RENDER_FPS,
    PerformanceItem.PACKET_LOSS,
    PerformanceItem.BITRATE,
    PerformanceItem.NETWORK_LATENCY,
    PerformanceItem.DECODE_LATENCY
  ]);
  return config;
}

// è·å–æ€§èƒ½é¡¹ç›®ä¿¡æ¯
export function getPerformanceItemInfo(item: PerformanceItem): PerformanceItemInfo {
  switch (item) {
    case PerformanceItem.RESOLUTION:
      return new PerformanceItemInfo(
        `${PerfIcons.RESOLUTION} åˆ†è¾¨ç‡`,
        'æ˜¾ç¤ºå½“å‰ä¸²æµçš„åˆ†è¾¨ç‡å’Œå¸§ç‡ã€‚å®¢æˆ·ç«¯åˆ†è¾¨ç‡æ˜¯ä»æœåŠ¡å™¨æ¥æ”¶çš„è§†é¢‘åˆ†è¾¨ç‡ï¼Œè¿™å¯èƒ½ä¸ä¸»æœºç«¯è®¾ç½®çš„åˆ†è¾¨ç‡ä¸åŒã€‚'
      );
    case PerformanceItem.DECODER:
      return new PerformanceItemInfo(
        `${PerfIcons.DECODER} è§£ç å™¨`,
        'æ˜¾ç¤ºå½“å‰ä½¿ç”¨çš„è§†é¢‘ç¼–è§£ç å™¨ã€‚HEVCæ¯”AVCæä¾›æ›´å¥½çš„å‹ç¼©æ•ˆç‡ï¼Œåœ¨ç›¸åŒç ç‡ä¸‹èƒ½è·å¾—æ›´å¥½çš„ç”»è´¨ã€‚HDRè¡¨ç¤ºæ­£åœ¨ä½¿ç”¨é«˜åŠ¨æ€èŒƒå›´ï¼Œèƒ½æ˜¾ç¤ºæ›´ä¸°å¯Œçš„è‰²å½©å’Œå¯¹æ¯”åº¦ã€‚'
      );
    case PerformanceItem.RENDER_FPS:
      return new PerformanceItemInfo(
        `ğŸ“Š å¸§ç‡`,
        'Rxä¸ºä»æœåŠ¡å™¨æ¥æ”¶çš„å¸§ç‡ï¼ŒRdä¸ºå®é™…æ¸²æŸ“åˆ°å±å¹•çš„å¸§ç‡ã€‚å¦‚æœæ¸²æŸ“å¸§ç‡ä½äºæ¥æ”¶å¸§ç‡ï¼Œå¯èƒ½æ˜¯è§£ç æˆ–æ˜¾ç¤ºç“¶é¢ˆã€‚'
      );
    case PerformanceItem.PACKET_LOSS:
      return new PerformanceItemInfo(
        `${PerfIcons.PACKET_LOSS} ä¸¢åŒ…ç‡`,
        'æ˜¾ç¤ºç½‘ç»œä¼ è¾“è¿‡ç¨‹ä¸­ä¸¢å¤±çš„æ•°æ®åŒ…ç™¾åˆ†æ¯”ã€‚ä½äº1%æ˜¯ä¼˜ç§€ï¼Œ1-5%æ˜¯å¯æ¥å—ï¼Œé«˜äº5%å¯èƒ½å¯¼è‡´ç”»é¢å¡é¡¿æˆ–èŠ±å±ã€‚'
      );
    case PerformanceItem.BITRATE:
      return new PerformanceItemInfo(
        `${PerfIcons.BITRATE} ç ç‡`,
        'å½“å‰è§†é¢‘æµçš„ä¸‹è½½å¸¦å®½ã€‚å¸¦å®½è¶Šé«˜ï¼Œç”»è´¨è¶Šå¥½ï¼Œä½†ä¹Ÿéœ€è¦æ›´å¿«çš„ç½‘ç»œè¿æ¥ã€‚å»ºè®®æ ¹æ®ç½‘ç»œå¸¦å®½è°ƒæ•´ç ç‡è®¾ç½®ã€‚'
      );
    case PerformanceItem.NETWORK_LATENCY:
      return new PerformanceItemInfo(
        `${PerfIcons.NETWORK} ç½‘ç»œå»¶è¿Ÿ`,
        'ç½‘ç»œå¾€è¿”å»¶è¿Ÿ(RTT)ï¼Œå³æ•°æ®åŒ…ä»å®¢æˆ·ç«¯åˆ°æœåŠ¡å™¨å†è¿”å›çš„æ—¶é—´ã€‚ä½äº20msæ˜¯ä¼˜ç§€ï¼Œ20-50msæ˜¯è‰¯å¥½ï¼Œé«˜äº100mså¯èƒ½æ„Ÿå—åˆ°æ˜æ˜¾å»¶è¿Ÿã€‚'
      );
    case PerformanceItem.DECODE_LATENCY:
      return new PerformanceItemInfo(
        `${PerfIcons.DECODE_NORMAL} è§£ç å»¶è¿Ÿ`,
        'è§†é¢‘å¸§è§£ç æ‰€éœ€çš„æ—¶é—´ã€‚ä½äº10msæ˜¯ä¼˜ç§€ï¼Œ10-20msæ˜¯æ­£å¸¸ï¼Œé«˜äº20mså¯èƒ½éœ€è¦é™ä½åˆ†è¾¨ç‡æˆ–ä½¿ç”¨ç¡¬ä»¶è§£ç å™¨ã€‚'
      );
    case PerformanceItem.HOST_LATENCY:
      return new PerformanceItemInfo(
        `${PerfIcons.HOST} ä¸»æœºå»¶è¿Ÿ`,
        'æœåŠ¡å™¨ç«¯æ¸²æŸ“å’Œç¼–ç æ¸¸æˆç”»é¢æ‰€éœ€çš„æ—¶é—´ã€‚è¿™å–å†³äºæœåŠ¡å™¨çš„ç¡¬ä»¶æ€§èƒ½å’Œå½“å‰è¿è¡Œçš„æ¸¸æˆã€‚è¾ƒæ–°çš„æ˜¾å¡é€šå¸¸æœ‰æ›´ä½çš„ç¼–ç å»¶è¿Ÿã€‚'
      );
    case PerformanceItem.BATTERY:
      return new PerformanceItemInfo(
        `${PerfIcons.BATTERY} ç”µæ± `,
        'æ˜¾ç¤ºå½“å‰è®¾å¤‡çš„ç”µæ± ç”µé‡ã€‚ä¸²æµæ¸¸æˆä¼šæ¶ˆè€—è¾ƒå¤šç”µé‡ï¼Œå»ºè®®åœ¨ç”µé‡å……è¶³æ—¶æˆ–è¿æ¥å……ç”µå™¨æ—¶è¿›è¡Œé•¿æ—¶é—´ä¸²æµã€‚'
      );
    default:
      return new PerformanceItemInfo('æœªçŸ¥', '');
  }
}

/**
 * è·å–æœˆç›¸å›¾æ ‡
 */
export function getMoonPhaseIcon(): string {
  const date = new Date();
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  
  // ç®€åŒ–çš„æœˆç›¸è®¡ç®—ï¼ˆåŸºäºæœ”æœ›æœˆå‘¨æœŸ 29.53 å¤©ï¼‰
  const lp = 2551443; // æœˆç›¸å‘¨æœŸï¼ˆç§’ï¼‰
  const newMoon = new Date(1970, 0, 7, 20, 35, 0); // å·²çŸ¥æ–°æœˆæ—¶é—´
  const phase = ((date.getTime() - newMoon.getTime()) / 1000) % lp;
  const phaseIndex = Math.floor(phase / (lp / 8));
  
  const icons = ['ğŸŒ‘', 'ğŸŒ’', 'ğŸŒ“', 'ğŸŒ”', 'ğŸŒ•', 'ğŸŒ–', 'ğŸŒ—', 'ğŸŒ˜'];
  return icons[phaseIndex] || 'ğŸŒ™';
}

/**
 * æ ¼å¼åŒ–ç ç‡æ˜¾ç¤º
 */
export function formatBitrate(bps: number): string {
  if (bps >= 1000000) {
    return `${(bps / 1000000).toFixed(1)} Mbps`;
  } else if (bps >= 1000) {
    return `${(bps / 1000).toFixed(0)} Kbps`;
  }
  return `${bps} bps`;
}

/**
 * æ ¼å¼åŒ–æ•°æ®æµé‡æ˜¾ç¤ºï¼ˆä»ç ç‡ bps è½¬æ¢ä¸ºæ¯ç§’æ•°æ®é‡ï¼‰
 * ç ç‡ (bps) è½¬æ¢ä¸ºå­—èŠ‚/ç§’ éœ€è¦é™¤ä»¥ 8
 */
export function formatDataRate(bps: number): string {
  const bytesPerSec = bps / 8;  // ä» bits è½¬æ¢ä¸º bytes
  
  if (bytesPerSec >= 1024 * 1024) {
    return `${(bytesPerSec / (1024 * 1024)).toFixed(1)} MB/s`;
  } else if (bytesPerSec >= 1024) {
    return `${(bytesPerSec / 1024).toFixed(0)} KB/s`;
  }
  return `${bytesPerSec.toFixed(0)} B/s`;
}

/**
 * æ ¼å¼åŒ–å»¶è¿Ÿæ˜¾ç¤º
 */
export function formatLatency(ms: number): string {
  return `${ms.toFixed(1)} ms`;
}

/**
 * è·å–è§£ç å™¨æ˜¾ç¤ºå­—ç¬¦ä¸²
 */
export function getDecoderString(codec: string, isHdr: boolean): string {
  let result = codec.toUpperCase();
  if (result.includes('HEVC') || result.includes('H265')) {
    result = 'HEVC';
  } else if (result.includes('AVC') || result.includes('H264')) {
    result = 'AVC';
  } else if (result.includes('AV1')) {
    result = 'AV1';
  }
  if (isHdr) {
    result += ' HDR';
  }
  return result;
}

/**
 * è·å–ä¸¢åŒ…ç‡é¢œè‰²
 */
export function getPacketLossColor(loss: number): string {
  if (loss < 1.0) return '#7D9D7D';  // ç»¿è‰² - ä¼˜ç§€
  if (loss < 5.0) return '#D4A574';  // æ©™è‰² - å¯æ¥å—
  return '#B57D7D';  // çº¢è‰² - å·®
}

/**
 * è·å–å»¶è¿Ÿé¢œè‰²
 */
export function getLatencyColor(ms: number): string {
  if (ms < 10) return '#7D9D7D';   // ç»¿è‰² - ä¼˜ç§€
  if (ms < 20) return '#D597E3';   // ç´«è‰² - æ­£å¸¸
  return '#B57D7D';  // çº¢è‰² - å·®
}

/**
 * è·å–ç”µæ± é¢œè‰²
 */
export function getBatteryColor(level: number): string {
  if (level > 50) return '#90EE90';  // æµ…ç»¿è‰² - å……è¶³
  if (level > 20) return '#FFA500';  // æ©™è‰² - åä½
  return '#FF6B6B';  // çº¢è‰² - ä¸è¶³
}

/**
 * æ˜¾ç¤ºæ€§èƒ½é¡¹ç›®è¯¦æƒ…å¯¹è¯æ¡†
 */
export function showItemInfoDialog(item: PerformanceItem, data: PerformanceData | null): void {
  const info = getPerformanceItemInfo(item);
  if (!info) return;
  
  let message = info.description;
  
  // æ·»åŠ å½“å‰æ•°å€¼
  if (data !== null) {
    switch (item) {
      case PerformanceItem.RESOLUTION:
        message = `${data.streamWidth}Ã—${data.streamHeight} @ ${data.renderedFps}/${data.targetFps} FPS\n\n${info.description}`;
        break;
      case PerformanceItem.DECODER:
        message = `${data.codec}${data.isHdr ? ' HDR' : ''}\n\n${info.description}`;
        break;
      case PerformanceItem.RENDER_FPS:
        message = `Rx: ${data.receivedFps}  Rd: ${data.renderedFps}\n\n${info.description}`;
        break;
      case PerformanceItem.PACKET_LOSS:
        message = `${data.packetLoss.toFixed(2)}%\n\n${info.description}`;
        break;
      case PerformanceItem.BITRATE:
        message = `${formatBitrate(data.bitrate)}\n\n${info.description}`;
        break;
      case PerformanceItem.NETWORK_LATENCY:
        message = `${data.networkLatency} ms\n\n${info.description}`;
        break;
      case PerformanceItem.DECODE_LATENCY:
        message = `${data.decodeLatency.toFixed(1)} ms\n\n${info.description}`;
        break;
      case PerformanceItem.HOST_LATENCY:
        message = `${data.hostLatency.toFixed(1)} ms\n\n${info.description}`;
        break;
      case PerformanceItem.BATTERY:
        message = `${data.batteryLevel}%${data.isCharging ? ' ğŸ”Œå……ç”µä¸­' : ''}\n\n${info.description}`;
        break;
    }
  }
  
  const dialogButton: promptAction.Button = { text: 'ç¡®å®š', color: '#0A59F7' };
  promptAction.showDialog({
    title: info.title,
    message: message,
    buttons: [dialogButton]
  });
}

/**
 * è®¡ç®—å¸é™„ä½ç½®åæ ‡
 */
export function calculateSnapPosition(
  position: SnapPosition,
  screenWidth: number,
  screenHeight: number,
  overlayWidth: number,
  overlayHeight: number,
  safeAreaTop: number = 8,
  safeAreaBottom: number = 0
): Position {
  const padding = 8;  // å·¦å³å®‰å…¨åŒºä¹Ÿè®¾ä¸º8
  
  let x: number;
  let y: number;
  
  switch (position) {
    case SnapPosition.TOP_LEFT:
      x = padding;
      y = safeAreaTop;
      break;
    case SnapPosition.TOP_CENTER:
      x = (screenWidth - overlayWidth) / 2;
      y = safeAreaTop;
      break;
    case SnapPosition.TOP_RIGHT:
      x = screenWidth - overlayWidth - padding;
      y = safeAreaTop;
      break;
    case SnapPosition.CENTER_LEFT:
      x = padding;
      y = (screenHeight - overlayHeight) / 2;
      break;
    case SnapPosition.CENTER_RIGHT:
      x = screenWidth - overlayWidth - padding;
      y = (screenHeight - overlayHeight) / 2;
      break;
    case SnapPosition.BOTTOM_LEFT:
      x = padding;
      y = screenHeight - overlayHeight - safeAreaBottom;
      break;
    case SnapPosition.BOTTOM_CENTER:
      x = (screenWidth - overlayWidth) / 2;
      y = screenHeight - overlayHeight - safeAreaBottom;
      break;
    case SnapPosition.BOTTOM_RIGHT:
      x = screenWidth - overlayWidth - padding;
      y = screenHeight - overlayHeight - safeAreaBottom;
      break;
    default:
      x = padding;
      y = safeAreaTop;
  }
  
  return new Position(x, y);
}

// æ‰€æœ‰å¸é™„ä½ç½®åˆ—è¡¨
const ALL_SNAP_POSITIONS: SnapPosition[] = [
  SnapPosition.TOP_LEFT,
  SnapPosition.TOP_CENTER,
  SnapPosition.TOP_RIGHT,
  SnapPosition.CENTER_LEFT,
  SnapPosition.CENTER_RIGHT,
  SnapPosition.BOTTOM_LEFT,
  SnapPosition.BOTTOM_CENTER,
  SnapPosition.BOTTOM_RIGHT
];

/**
 * æ‰¾åˆ°æœ€è¿‘çš„å¸é™„ä½ç½®
 */
export function findNearestSnapPosition(
  currentX: number,
  currentY: number,
  screenWidth: number,
  screenHeight: number,
  overlayWidth: number,
  overlayHeight: number
): SnapPosition {
  let nearestPosition = SnapPosition.TOP_LEFT;
  let minDistance = Infinity;
  
  for (let i = 0; i < ALL_SNAP_POSITIONS.length; i++) {
    const pos = ALL_SNAP_POSITIONS[i];
    const snapPos = calculateSnapPosition(pos, screenWidth, screenHeight, overlayWidth, overlayHeight);
    const distance = Math.sqrt(Math.pow(currentX - snapPos.x, 2) + Math.pow(currentY - snapPos.y, 2));
    
    if (distance < minDistance) {
      minDistance = distance;
      nearestPosition = pos;
    }
  }
  
  return nearestPosition;
}
