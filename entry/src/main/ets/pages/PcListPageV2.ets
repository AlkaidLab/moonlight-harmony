/*
 * Moonlight for HarmonyOS
 * Copyright (C) 2024-2025 Moonlight/AlkaidLab
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

import { router, promptAction } from '@kit.ArkUI';
import { ComputerInfo, ComputerState, PairState } from '../model/ComputerInfo';
import { ComputerManager } from '../service/ComputerManager';
import { ComputerCard } from '../components/ComputerCard';
import { ComputerListViewModel, ObservableComputer, ComputerDataSource } from '../viewmodel/ComputerViewModel';
import { AppColors, AppSizes, AppSpacing, AppAnimation, AppShadows } from '../common/Theme';
import { PairingManager, PairState as PMPairState } from '../service/PairingManager';
import { NvHttp } from '../service/NvHttp';
import { common, bundleManager, Want } from '@kit.AbilityKit';
import { buffer } from '@kit.ArkTS';
import { BackgroundImageUtil } from '../utils/BackgroundImageUtil';
import { BackgroundImage } from '../components/BackgroundImage';
import { sensor } from '@kit.SensorServiceKit';
import { OptionPickerDialog, OptionPickerDialogConfig, OptionItem } from '../components/OptionPickerDialog';
import { ConfirmDialog, ConfirmDialogConfig, InfoDialog, InfoDialogConfig } from '../components/ConfirmDialog';
import { BusinessError } from '@kit.BasicServicesKit';
import { photoAccessHelper } from '@kit.MediaLibraryKit';
import { fileIo } from '@kit.CoreFileKit';

/**
 * ç”µè„‘åˆ—è¡¨é¡µé¢ (ç°ä»£åŒ–ç‰ˆæœ¬)
 * 
 * åŠŸèƒ½:
 * - æ˜¾ç¤ºå·²æ·»åŠ çš„ç”µè„‘åˆ—è¡¨
 * - æ”¯æŒä¸‹æ‹‰åˆ·æ–°
 * - æ”¯æŒ mDNS è‡ªåŠ¨å‘ç°
 * - æ”¯æŒ WOL å”¤é†’
 * - æ”¯æŒé…å¯¹/å–æ¶ˆé…å¯¹
 */
@Entry
@Component
struct PcListPageV2 {
  @State viewModel: ComputerListViewModel = new ComputerListViewModel();
  @State isRefreshing: boolean = false;
  @State isScanning: boolean = false;
  @State isInitializing: boolean = true;
  @State showPinDialog: boolean = false;
  @State currentPin: string = '';
  @State pairingComputerName: string = '';
  @State backgroundImageUrl: string = '';
  @State showAboutDialog: boolean = false;
  @State isLandscape: boolean = false;  // æ¨ªå±æ£€æµ‹
  @State screenWidth: number = 0;       // å±å¹•å®½åº¦
  
  // LazyForEach æ•°æ®æº
  private computerDataSource: ComputerDataSource = new ComputerDataSource();
  
  private computerManager: ComputerManager = ComputerManager.getInstance();
  private backgroundUtil: BackgroundImageUtil = BackgroundImageUtil.getInstance();
  
  // æ‘‡ä¸€æ‘‡ç›¸å…³
  private lastShakeTime: number = 0;
  private shakeThreshold: number = 15; // åŠ é€Ÿåº¦é˜ˆå€¼
  private shakeCooldown: number = 2000; // 2ç§’å†·å´æ—¶é—´
  
  // CustomDialogController é…ç½®
  private optionPickerDialogConfig: OptionPickerDialogConfig = {
    title: '',
    options: [],
    onSelect: () => {}
  };
  private confirmDialogConfig: ConfirmDialogConfig = {
    title: '',
    message: '',
    confirmButton: { text: '', onClick: () => {} }
  };
  private infoDialogConfig: InfoDialogConfig = {
    title: '',
    content: ''
  };
  
  // CustomDialogController å®ä¾‹
  private optionPickerDialogController: CustomDialogController | null = null;
  private confirmDialogController: CustomDialogController | null = null;
  private infoDialogController: CustomDialogController | null = null;

  /**
   * æ˜¾ç¤ºç¡®è®¤å¼¹çª—
   */
  private showConfirmDialog(config: ConfirmDialogConfig): void {
    this.confirmDialogConfig = config;
    this.confirmDialogController = new CustomDialogController({
      builder: ConfirmDialog({
        config: this.confirmDialogConfig
      }),
      alignment: DialogAlignment.Center,
      customStyle: true,
      backgroundColor: Color.Transparent
    });
    this.confirmDialogController.open();
  }
  
  /**
   * æ˜¾ç¤ºä¿¡æ¯å¼¹çª—
   */
  private showInfoDialog(config: InfoDialogConfig): void {
    this.infoDialogConfig = config;
    this.infoDialogController = new CustomDialogController({
      builder: InfoDialog({
        config: this.infoDialogConfig
      }),
      alignment: DialogAlignment.Center,
      customStyle: true,
      backgroundColor: Color.Transparent
    });
    this.infoDialogController.open();
  }

  aboutToAppear(): void {
    // å…ˆè®¾ç½® context ä»¥ä¾¿åç»­ä½¿ç”¨æœ¬åœ°ç¼“å­˜
    const context = getContext(this) as common.UIAbilityContext;
    this.backgroundUtil.setContext(context);
    
    this.initializeAsync();
    this.loadBackgroundImage();
    this.startShakeDetection();
  }
  
  private async loadBackgroundImage(): Promise<void> {
    try {
      // é¦–æ¬¡ä½¿ç”¨æ£€æŸ¥å…è´£å£°æ˜
      const disclaimerAccepted = await this.backgroundUtil.isDisclaimerAccepted();
      if (!disclaimerAccepted) {
        // æ˜¾ç¤ºå…è´£å£°æ˜å¼¹çª—
        this.showBackgroundDisclaimerDialog();
        return;
      }
      
      // ä¼˜å…ˆä½¿ç”¨æœ¬åœ°ç¼“å­˜çš„å›¾ç‰‡
      const localPath = await this.backgroundUtil.downloadToLocalCache();
      if (localPath) {
        this.backgroundImageUrl = 'file://' + localPath;
      } else {
        // å¦‚æœæœ¬åœ°ç¼“å­˜å¤±è´¥ï¼Œä½¿ç”¨åœ¨çº¿ URL
        this.backgroundImageUrl = await this.backgroundUtil.getBackgroundImageUrl();
      }
    } catch (err) {
      // å¿½ç•¥é”™è¯¯
    }
  }
  
  /**
   * æ˜¾ç¤ºèƒŒæ™¯å›¾å…è´£å£°æ˜å¼¹çª—
   */
  private showBackgroundDisclaimerDialog(): void {
    const config: ConfirmDialogConfig = {
      title: 'èƒŒæ™¯å£çº¸åŠŸèƒ½è¯´æ˜',
      message: 'æœ¬åº”ç”¨çš„èƒŒæ™¯å£çº¸æ¥è‡ªäº’è”ç½‘å…¬å¼€èµ„æºï¼ˆPipw APIï¼‰ï¼Œå›¾ç‰‡ç‰ˆæƒå½’åŸä½œè€…æ‰€æœ‰ã€‚\n\n' +
        'â€¢ æœ¬åº”ç”¨ä»…æä¾›æŠ€æœ¯é“¾æ¥ï¼Œä¸å­˜å‚¨ã€ä¸æ‹¥æœ‰è¿™äº›å›¾ç‰‡çš„ç‰ˆæƒ\n' +
        'â€¢ å¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åŸå›¾ç‰‡æ¥æºæ–¹\n' +
        'â€¢ æ‚¨å¯ä»¥åœ¨è®¾ç½®ä¸­éšæ—¶å…³é—­å£çº¸åŠŸèƒ½æˆ–åˆ‡æ¢ä¸ºå…¶ä»–æ¥æº\n\n' +
        'ç»§ç»­ä½¿ç”¨å³è¡¨ç¤ºæ‚¨çŸ¥æ‚‰å¹¶åŒæ„ä¸Šè¿°æ¡æ¬¾ã€‚',
      cancelButton: {
        text: 'å…³é—­å£çº¸',
        onClick: async () => {
          // ç”¨æˆ·é€‰æ‹©å…³é—­å£çº¸ï¼Œè®¾ç½®ä¸º NONE
          await this.backgroundUtil.setDisclaimerAccepted();
          await this.backgroundUtil.disableBackgroundImage();
          this.backgroundImageUrl = '';
        }
      },
      confirmButton: {
        text: 'çŸ¥æ‚‰å¹¶ç»§ç»­',
        onClick: async () => {
          // ç”¨æˆ·åŒæ„ï¼Œä¿å­˜çŠ¶æ€å¹¶åŠ è½½å£çº¸
          await this.backgroundUtil.setDisclaimerAccepted();
          this.loadBackgroundImageAfterDisclaimer();
        }
      }
    };
    this.showConfirmDialog(config);
  }
  
  /**
   * å…è´£å£°æ˜ç¡®è®¤ååŠ è½½èƒŒæ™¯å›¾
   */
  private async loadBackgroundImageAfterDisclaimer(): Promise<void> {
    try {
      const localPath = await this.backgroundUtil.downloadToLocalCache();
      if (localPath) {
        this.backgroundImageUrl = 'file://' + localPath;
      } else {
        this.backgroundImageUrl = await this.backgroundUtil.getBackgroundImageUrl();
      }
    } catch (err) {
      // å¿½ç•¥é”™è¯¯
    }
  }

  private async initializeAsync(): Promise<void> {
    try {
      const context = getContext(this) as common.UIAbilityContext;
      await this.computerManager.init(context);

      this.computerManager.setOnComputerListChangedListener(() => {
        this.syncViewModelFromManager();
      });

      this.syncViewModelFromManager();
      this.computerManager.startBackgroundScan();
      
      this.isInitializing = false;
      
      // å¼‚æ­¥åˆ·æ–°çŠ¶æ€
      this.computerManager.refreshAllComputers().then(() => {
        this.syncViewModelFromManager();
        // å¯åŠ¨è½®è¯¢
        this.computerManager.startPolling();
      }).catch((err: Error) => {
        console.error('[MOONLIGHT] PcListPage: åˆ·æ–°å¤±è´¥', err);
        // å¯åŠ¨è½®è¯¢
        this.computerManager.startPolling();
      });
    } catch (err) {
      console.error('PcListPage: åˆå§‹åŒ–å¤±è´¥', err);
      this.isInitializing = false;
    }
  }
  
  private async syncViewModelFromManager(): Promise<void> {
    const computers = await this.computerManager.getComputers();
    
    // åˆ›å»º UUID åˆ°ç”µè„‘ä¿¡æ¯çš„æ˜ å°„
    const computerMap = new Map<string, ComputerInfo>();
    for (const c of computers) {
      computerMap.set(c.uuid, c);
    }
    
    // è·å–ç°æœ‰çš„ ObservableComputer åˆ—è¡¨
    const existingMap = new Map<string, ObservableComputer>();
    for (const oc of this.viewModel.computers) {
      existingMap.set(oc.uuid, oc);
    }
    
    // æ„å»ºæ–°çš„åˆ—è¡¨ï¼Œå¤ç”¨ç°æœ‰å¯¹è±¡ä»¥é¿å…é‡æ–°æ¸²æŸ“
    const newList: ObservableComputer[] = [];
    let hasChanges = false;
    
    for (const c of computers) {
      const existing = existingMap.get(c.uuid);
      if (existing) {
        // æ›´æ–°ç°æœ‰å¯¹è±¡çš„å±æ€§ï¼ˆ@Observed ä¼šå¤„ç†å“åº”å¼æ›´æ–°ï¼‰
        existing.updateFrom(c);
        newList.push(existing);
        existingMap.delete(c.uuid);
      } else {
        // æ–°ç”µè„‘ï¼Œåˆ›å»ºæ–°å¯¹è±¡
        newList.push(new ObservableComputer(c));
        hasChanges = true;
      }
    }
    
    // å¦‚æœæœ‰ç”µè„‘è¢«åˆ é™¤
    if (existingMap.size > 0) {
      hasChanges = true;
    }
    
    // åªæœ‰å½“ç”µè„‘æ•°é‡å˜åŒ–æ—¶æ‰æ›¿æ¢æ•´ä¸ªæ•°ç»„
    if (hasChanges || this.viewModel.computers.length !== newList.length) {
      this.viewModel.computers = newList;
      // åŒæ­¥æ›´æ–° LazyForEach æ•°æ®æº
      this.computerDataSource.reloadData(newList);
    }
    
    // æ›´æ–°ç¼“å­˜çš„ç»Ÿè®¡å€¼ï¼Œç¡®ä¿ UI æ˜¾ç¤ºæ­£ç¡®
    this.viewModel.computerCount = newList.length;
    this.viewModel.onlineCount = newList.filter(c => c.isOnline).length;
  }

  aboutToDisappear(): void {
    this.computerManager.stopBackgroundScan();
    this.computerManager.stopPolling();
    this.stopShakeDetection();
  }

  onPageShow(): void {
    // é¡µé¢å†æ¬¡æ˜¾ç¤ºæ—¶å¯åŠ¨è½®è¯¢
    this.computerManager.startPolling();
    if (!this.isInitializing) {
      // å…ˆåŒæ­¥å½“å‰æ•°æ®
      this.syncViewModelFromManager();
      // ç«‹å³åˆ·æ–°ä¸€æ¬¡çŠ¶æ€ï¼ˆå¼‚æ­¥ï¼‰ï¼Œç¡®ä¿æ˜¾ç¤ºæœ€æ–°çš„æ¸¸æˆè¿è¡ŒçŠ¶æ€
      this.computerManager.refreshAllComputers().then(() => {
        this.syncViewModelFromManager();
      }).catch((err: Error) => {
        console.warn('[MOONLIGHT] PcListPage: åˆ·æ–°å¤±è´¥', err);
      });
    }
    // é‡æ–°å¯åŠ¨æ‘‡ä¸€æ‘‡æ£€æµ‹
    this.startShakeDetection();
  }
  
  onPageHide(): void {
    // é¡µé¢éšè—æ—¶åœæ­¢è½®è¯¢ï¼ˆèŠ‚çœèµ„æºï¼‰
    this.computerManager.stopPolling();
    // åœæ­¢æ‘‡ä¸€æ‘‡æ£€æµ‹
    this.stopShakeDetection();
  }
  
  // å¯åŠ¨æ‘‡ä¸€æ‘‡æ£€æµ‹
  private startShakeDetection(): void {
    try {
      sensor.on(sensor.SensorId.ACCELEROMETER, (data) => {
        const x = data.x;
        const y = data.y;
        const z = data.z;
        const acceleration = Math.sqrt(x * x + y * y + z * z);
        
        // æ£€æµ‹æ˜¯å¦è¶…è¿‡é˜ˆå€¼ï¼ˆæ‘‡ä¸€æ‘‡åŠ¨ä½œï¼‰
        // æ­£å¸¸é‡åŠ›åŠ é€Ÿåº¦çº¦ä¸º9.8ï¼Œéœ€è¦å‡å»
        const shakeForce = Math.abs(acceleration - 9.8);
        
        if (shakeForce > this.shakeThreshold) {
          const now = Date.now();
          // å†·å´æ—¶é—´æ£€æŸ¥ï¼Œé˜²æ­¢è¿ç»­è§¦å‘
          if (now - this.lastShakeTime > this.shakeCooldown) {
            this.lastShakeTime = now;
            this.refreshWallpaper();
          }
        }
      }, { interval: 100000000 }); // 100ms é‡‡æ ·é—´éš”
    } catch (err) {
      // æŸäº›è®¾å¤‡å¯èƒ½ä¸æ”¯æŒåŠ é€Ÿåº¦ä¼ æ„Ÿå™¨
    }
  }
  
  // åœæ­¢æ‘‡ä¸€æ‘‡æ£€æµ‹
  private stopShakeDetection(): void {
    try {
      sensor.off(sensor.SensorId.ACCELEROMETER);
    } catch (err) {
      // å¿½ç•¥é”™è¯¯
    }
  }

  build() {
    Stack() {
      // èƒŒæ™¯å›¾å±‚
      BackgroundImage({ imageUrl: this.backgroundImageUrl, imageOpacity: 0.7 })
      
      // ä¸»å†…å®¹
      Column() {
        // æ ‡é¢˜æ 
        this.TitleBar()
        
        // ç”µè„‘åˆ—è¡¨æˆ–ç©ºçŠ¶æ€
        if (this.isInitializing) {
          this.LoadingState()
        } else if (this.viewModel.computers.length === 0) {
          this.EmptyState()
        } else {
          this.ComputerList()
        }
        
        // åº•éƒ¨æ“ä½œæ  (æœ‰ç”µè„‘æ—¶æ˜¾ç¤ºï¼Œç©ºçŠ¶æ€ç”± EmptyState è‡ªå¸¦æŒ‰é’®)
        if (!this.isInitializing && this.viewModel.computers.length > 0) {
          this.BottomBar()
        }
      }
      .width('100%')
      .height('100%')
      
      // PIN å¯¹è¯æ¡†
      if (this.showPinDialog) {
        this.PinDialog()
      }
      
      // å…³äºå¯¹è¯æ¡†
      if (this.showAboutDialog) {
        this.AboutDialog()
      }
    }
    .width('100%')
    .height('100%')
    .onAreaChange((oldValue: Area, newValue: Area) => {
      // æ£€æµ‹å±å¹•å°ºå¯¸å˜åŒ–ï¼ˆæ—‹è½¬å±å¹•æ—¶ï¼‰
      const width = newValue.width as number;
      const height = newValue.height as number;
      this.screenWidth = width;
      this.isLandscape = width > height;
    })
  }

  @Builder
  TitleBar() {
    Row() {
      Column() {
        Row() {
          // åº”ç”¨å›¾æ ‡/Logo - ä½¿ç”¨ V+ Logo
          Image($r('app.media.vplus'))
            .width(44)
            .height(44)
            .borderRadius(12)
            .objectFit(ImageFit.Cover)
            .margin({ right: AppSpacing.Medium })

          Column() {
            Text('Moonlight V+')
              .fontSize(AppSizes.FontLargeTitle)
              .fontWeight(FontWeight.Bold)
              .fontColor(AppColors.Primary)

            if (this.viewModel.computers.length > 0) {
              Row() {
                Circle()
                  .width(6)
                  .height(6)
                  .fill(AppColors.Online)
                  .margin({ right: 6 })
                Text(`${this.viewModel.onlineCount} åœ¨çº¿`)
                  .fontSize(AppSizes.FontCaption)
                  .fontColor(AppColors.Online)
                Text(` / ${this.viewModel.computerCount} å°è®¾å¤‡`)
                  .fontSize(AppSizes.FontCaption)
                  .fontColor(AppColors.TextSecondary)
              }
              .margin({ top: 4 })
            }
          }
          .alignItems(HorizontalAlign.Start)
        }
      }
      .alignItems(HorizontalAlign.Start)

      Blank()

      // å…³äºæŒ‰é’®
      Button({ type: ButtonType.Circle }) {
        Image($r('app.media.ic_info'))
          .width(AppSizes.IconMedium)
          .height(AppSizes.IconMedium)
          .fillColor(AppColors.Primary)
      }
      .width(44)
      .height(44)
      .backgroundColor(AppColors.Surface)
      .borderWidth(1)
      .borderColor(AppColors.CardBorder)
      .margin({ right: AppSpacing.Small })
      .onClick(() => {
        this.showAboutDialog = true;
      })

      // è®¾ç½®æŒ‰é’®
      Button({ type: ButtonType.Circle }) {
        Image($r('app.media.ic_settings'))
          .width(AppSizes.IconMedium)
          .height(AppSizes.IconMedium)
          .fillColor(AppColors.Primary)
      }
      .width(44)
      .height(44)
      .backgroundColor(AppColors.Surface)
      .borderWidth(1)
      .borderColor(AppColors.CardBorder)
      .onClick(() => {
        router.pushUrl({ url: 'pages/SettingsPageV2' });
      })
    }
    .width('100%')
    .padding({
      left: AppSpacing.Large,
      right: AppSpacing.Large,
      top: 56,
      bottom: AppSpacing.Large
    })
  }

  @Builder
  LoadingState() {
    Column() {
      LoadingProgress()
        .width(48)
        .height(48)
        .color(AppColors.Primary)
      Text('æ­£åœ¨åŠ è½½...')
        .fontSize(AppSizes.FontBody)
        .fontColor(AppColors.TextSecondary)
        .margin({ top: AppSpacing.Large })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }

  @Builder
  EmptyState() {
    Column() {
      // éœ“è™¹é£æ ¼æ’å›¾
      Column() {
        Text('ğŸ–¥ï¸')
          .fontSize(48)
      }
      .width(120)
      .height(120)
      .borderRadius(60)
      .backgroundColor(AppColors.Surface)
      .borderWidth(2)
      .borderColor(AppColors.Primary)
      .justifyContent(FlexAlign.Center)
      .margin({ bottom: AppSpacing.XLarge })

      Text('å¼€å§‹è¿æ¥')
        .fontSize(AppSizes.FontTitle)
        .fontWeight(FontWeight.Bold)
        .fontColor(AppColors.Primary)
        .margin({ bottom: AppSpacing.Small })

      Text('æ‰«æç½‘ç»œå‘ç°è¿è¡Œ Foundation Sunshine çš„ç”µè„‘')
        .fontSize(AppSizes.FontBody)
        .fontColor(AppColors.TextSecondary)
        .textAlign(TextAlign.Center)
        .padding({ left: AppSpacing.XXLarge, right: AppSpacing.XXLarge })

      Text('æˆ–æ‰‹åŠ¨è¾“å…¥ IP åœ°å€æ·»åŠ ')
        .fontSize(AppSizes.FontCaption)
        .fontColor(AppColors.TextTertiary)
        .margin({ top: AppSpacing.Small })

      // å¿«é€Ÿæ“ä½œæŒ‰é’® - éœ“è™¹é£æ ¼
      Row() {
        Button({ type: ButtonType.Normal }) {
          Row() {
            Image($r('app.media.ic_scan'))
              .width(20)
              .height(20)
              .fillColor(AppColors.TextOnPrimary)
              .margin({ right: 8 })
            Text('æ‰«æç½‘ç»œ')
              .fontSize(AppSizes.FontBody)
              .fontWeight(FontWeight.Medium)
              .fontColor(AppColors.TextOnPrimary)
          }
        }
        .height(48)
        .padding({ left: AppSpacing.XLarge, right: AppSpacing.XLarge })
        .borderRadius(AppSizes.RadiusLarge)
        .backgroundColor(AppColors.Primary)
        .onClick(() => this.scanNetwork())

        Button({ type: ButtonType.Normal }) {
          Row() {
            Image($r('app.media.ic_add'))
              .width(20)
              .height(20)
              .fillColor(AppColors.Primary)
              .margin({ right: 8 })
            Text('æ‰‹åŠ¨æ·»åŠ ')
              .fontSize(AppSizes.FontBody)
              .fontWeight(FontWeight.Medium)
              .fontColor(AppColors.Primary)
          }
        }
        .height(48)
        .padding({ left: AppSpacing.XLarge, right: AppSpacing.XLarge })
        .borderRadius(AppSizes.RadiusLarge)
        .backgroundColor(Color.Transparent)
        .borderWidth(1.5)
        .borderColor(AppColors.Primary)
        .margin({ left: AppSpacing.Medium })
        .onClick(() => router.pushUrl({ url: 'pages/AddPcPageV2' }))
      }
      .margin({ top: AppSpacing.XXLarge })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }

  /**
   * è®¡ç®—ç½‘æ ¼åˆ—æ•°
   * æ¨ªå±æˆ–å®½å±æ—¶ä½¿ç”¨å¤šåˆ—å¸ƒå±€
   */
  private getGridColumns(): number {
    if (this.screenWidth >= 900) return 3;  // å¤§å±å¹• 3 åˆ—
    if (this.screenWidth >= 600 || this.isLandscape) return 2;  // ä¸­ç­‰å±å¹•æˆ–æ¨ªå± 2 åˆ—
    return 1;  // ç«–å±å•åˆ—
  }

  @Builder
  ComputerList() {
    Refresh({ refreshing: $$this.isRefreshing }) {
      if (this.getGridColumns() > 1) {
        // æ¨ªå±/å®½å±ï¼šä½¿ç”¨ Grid å¸ƒå±€
        Grid() {
          ForEach(this.viewModel.computers, (computer: ObservableComputer, index: number) => {
            GridItem() {
              ComputerCard({
                computer: computer,
                onTap: () => this.handleComputerTap(computer),
                onLongPress: () => this.showComputerMenu(computer),
                onQuickStream: () => this.handleQuickStream(computer)
              })
            }
          }, (computer: ObservableComputer) => computer.uuid)
        }
        .columnsTemplate(this.getGridColumns() === 3 ? '1fr 1fr 1fr' : '1fr 1fr')
        .columnsGap(AppSpacing.Medium)
        .rowsGap(AppSpacing.Medium)
        .width('100%')
        .padding({ left: AppSpacing.Large, right: AppSpacing.Large })
        .scrollBar(BarState.Off)
        .edgeEffect(EdgeEffect.Spring)
      } else {
        // ç«–å±ï¼šä½¿ç”¨ List å¸ƒå±€
        List({ space: AppSpacing.Medium }) {
          LazyForEach(this.computerDataSource, (computer: ObservableComputer, index: number) => {
            ListItem() {
              ComputerCard({
                computer: computer,
                onTap: () => this.handleComputerTap(computer),
                onLongPress: () => this.showComputerMenu(computer),
                onQuickStream: () => this.handleQuickStream(computer)
              })
            }
          }, (computer: ObservableComputer) => computer.uuid)
        }
        .width('100%')
        .padding({ left: AppSpacing.Large, right: AppSpacing.Large })
        .scrollBar(BarState.Off)
        .edgeEffect(EdgeEffect.Spring)
        .cachedCount(5)
      }
    }
    .layoutWeight(1)
    .onRefreshing(() => {
      this.refreshComputers();
    })
  }

  @Builder
  BottomBar() {
    Row() {
      // æ‰«ææŒ‰é’® - æœç´¢ç½‘ç»œç”µè„‘
      Button({ type: ButtonType.Circle }) {
        if (this.isScanning) {
          LoadingProgress()
            .width(22)
            .height(22)
            .color(AppColors.TextSecondary)
        } else {
          Image($r('app.media.ic_search_network'))
            .width(22)
            .height(22)
            .fillColor(AppColors.TextSecondary)
        }
      }
      .width(44)
      .height(44)
      .backgroundColor(0x1A000000)  // ä¸ SaveButton ä¿æŒä¸€è‡´çš„åŠé€æ˜èƒŒæ™¯
      .enabled(!this.isScanning)
      .onClick(() => this.scanNetwork())

      // æ·»åŠ æŒ‰é’® - çªå‡ºæ˜¾ç¤ºçš„ä¸­å¤®å¤§æŒ‰é’®
      Button({ type: ButtonType.Circle }) {
        Image($r('app.media.ic_add'))
          .width(28)
          .height(28)
          .fillColor(Color.White)
      }
      .width(56)
      .height(56)
      .backgroundColor(AppColors.Primary)
      .shadow({
        radius: 12,
        color: AppColors.PrimaryGlow,
        offsetX: 0,
        offsetY: 4
      })
      .margin({ left: AppSpacing.XLarge, right: AppSpacing.XLarge })
      .onClick(() => router.pushUrl({ url: 'pages/AddPcPageV2' }))
      
      // ä¸‹è½½å£çº¸åˆ°ç›¸å†Œ - ä½¿ç”¨ SaveButton å®‰å…¨æ§ä»¶
      // æ³¨æ„ï¼šSaveButton ä½œä¸ºå®‰å…¨æ§ä»¶ï¼ŒèƒŒæ™¯è‰²é€æ˜åº¦æœ‰æœ€ä½é™åˆ¶ (Î± >= 0x1A)
      SaveButton({ 
        icon: SaveIconStyle.FULL_FILLED, 
        buttonType: ButtonType.Circle 
      })
        .width(44)
        .height(44)
        .iconSize(22)
        .iconColor(AppColors.TextSecondary)
        .backgroundColor(0x1A000000)  // æœ€ä½é€æ˜åº¦çš„é»‘è‰²èƒŒæ™¯
        .onClick(this.handleSaveWallpaperClick)
    }
    .width('100%')
    .justifyContent(FlexAlign.Center)
    .alignItems(VerticalAlign.Center)
    .padding({
      left: AppSpacing.Large,
      right: AppSpacing.Large,
      top: AppSpacing.Small,
      bottom: AppSpacing.Medium
    })
  }
  
  // åˆ·æ–°å£çº¸ï¼ˆè·å–æ–°çš„éšæœºå›¾ç‰‡ï¼‰- ç”±æ‘‡ä¸€æ‘‡è§¦å‘
  private async refreshWallpaper(): Promise<void> {
    try {
      promptAction.showToast({ message: 'æ­£åœ¨åˆ·æ–°å£çº¸...' });
      const localPath = await this.backgroundUtil.downloadToLocalCache(true); // forceRefresh = true
      if (localPath) {
        // æ·»åŠ æ—¶é—´æˆ³å‚æ•°å¼ºåˆ¶ Image ç»„ä»¶é‡æ–°åŠ è½½ï¼ˆç»•è¿‡ç¼“å­˜ï¼‰
        this.backgroundImageUrl = 'file://' + localPath + '?t=' + Date.now();
        promptAction.showToast({ message: 'å£çº¸å·²åˆ·æ–°' });
      } else {
        promptAction.showToast({ message: 'åˆ·æ–°å¤±è´¥' });
      }
    } catch (err) {
      promptAction.showToast({ message: 'åˆ·æ–°å£çº¸å¤±è´¥' });
    }
  }
  
  /**
   * SaveButton ä¿å­˜å£çº¸ç‚¹å‡»å›è°ƒ
   * ä½¿ç”¨å®‰å…¨æ§ä»¶æˆæƒåä¿å­˜å›¾ç‰‡åˆ°ç›¸å†Œ
   */
  handleSaveWallpaperClick: SaveButtonCallback = async (
    event: ClickEvent, 
    result: SaveButtonOnClickResult, 
    error?: BusinessError
  ) => {
    if (result === SaveButtonOnClickResult.SUCCESS) {
      const localPath = this.backgroundUtil.getLocalCachePath();
      if (!localPath) {
        promptAction.showToast({ message: 'æ²¡æœ‰å¯ä¸‹è½½çš„å£çº¸' });
        return;
      }
      
      try {
        const context = getContext(this) as common.UIAbilityContext;
        promptAction.showToast({ message: 'æ­£åœ¨ä¿å­˜å£çº¸...' });
        
        // è¯»å–æœ¬åœ°ç¼“å­˜æ–‡ä»¶
        const stat = fileIo.statSync(localPath);
        if (!stat || stat.size === 0) {
          promptAction.showToast({ message: 'ç¼“å­˜å›¾ç‰‡ä¸å­˜åœ¨' });
          return;
        }
        
        const file = fileIo.openSync(localPath, fileIo.OpenMode.READ_ONLY);
        const imageData = new ArrayBuffer(stat.size);
        fileIo.readSync(file.fd, imageData);
        fileIo.closeSync(file.fd);
        
        // ä½¿ç”¨ SaveButton æˆæƒååˆ›å»ºå›¾ç‰‡èµ„æº
        const helper = photoAccessHelper.getPhotoAccessHelper(context);
        const uri = await helper.createAsset(photoAccessHelper.PhotoType.IMAGE, 'jpg');
        
        // å†™å…¥å›¾ç‰‡æ•°æ®
        const photoFile = await fileIo.open(uri, fileIo.OpenMode.READ_WRITE | fileIo.OpenMode.CREATE);
        await fileIo.write(photoFile.fd, imageData);
        await fileIo.close(photoFile.fd);
        
        promptAction.showToast({ message: 'å£çº¸å·²ä¿å­˜åˆ°ç›¸å†Œ' });
      } catch (err) {
        console.error('ä¸‹è½½å£çº¸å¤±è´¥', err);
        const e = err as BusinessError;
        promptAction.showToast({ message: `ä¿å­˜å¤±è´¥: ${e.message || 'æœªçŸ¥é”™è¯¯'}` });
      }
    } else if (result === SaveButtonOnClickResult.TEMPORARY_AUTHORIZATION_FAILED) {
      console.error('ä¿å­˜æˆæƒå¤±è´¥', error);
      promptAction.showToast({ message: 'ä¿å­˜æˆæƒå¤±è´¥' });
    }
  };
  
  @Builder
  PinDialog() {
    Column() {
      // èƒŒæ™¯é®ç½©
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor('#66000000')
        .onClick(() => {
          this.showPinDialog = false;
        })
    }
    .width('100%')
    .height('100%')
    .position({ x: 0, y: 0 })
    .zIndex(100)
    
    // å¯¹è¯æ¡†
    Column() {
      // æ ‡é¢˜
      Text('é…å¯¹ PIN ç ')
        .fontSize(AppSizes.FontHeadline)
        .fontWeight(FontWeight.Bold)
        .fontColor(AppColors.TextPrimary)
        .margin({ bottom: AppSpacing.Medium })
      
      Text(`è¯·åœ¨ ${this.pairingComputerName} ä¸Šè¾“å…¥ä»¥ä¸‹ PIN ç ï¼š`)
        .fontSize(AppSizes.FontBody)
        .fontColor(AppColors.TextSecondary)
        .textAlign(TextAlign.Center)
        .margin({ bottom: AppSpacing.Large })
      
      // PIN ç æ˜¾ç¤º
      Row() {
        ForEach(this.currentPin.split(''), (digit: string) => {
          Text(digit)
            .fontSize(36)
            .fontWeight(FontWeight.Bold)
            .fontColor(AppColors.Primary)
            .width(56)
            .height(72)
            .textAlign(TextAlign.Center)
            .backgroundColor('#E8F2FF')
            .borderRadius(AppSizes.RadiusMedium)
        })
      }
      .justifyContent(FlexAlign.SpaceEvenly)
      .width('100%')
      .margin({ bottom: AppSpacing.XLarge })
      
      // æç¤º
      Text('æ­£åœ¨ç­‰å¾…é…å¯¹å®Œæˆ...')
        .fontSize(AppSizes.FontCaption)
        .fontColor(AppColors.TextSecondary)
        
      // å…³é—­æŒ‰é’®
      Button('å–æ¶ˆ')
        .width('100%')
        .height(44)
        .fontSize(AppSizes.FontBody)
        .fontColor(AppColors.TextSecondary)
        .backgroundColor(Color.Transparent)
        .margin({ top: AppSpacing.Large })
        .onClick(() => {
          this.showPinDialog = false;
        })
    }
    .width('85%')
    .padding(AppSpacing.XLarge)
    .backgroundColor(AppColors.Surface)
    .borderRadius(AppSizes.RadiusXLarge)
    .position({ x: '7.5%', y: '30%' })
    .zIndex(101)
  }
  
  @Builder
  AboutDialog() {
    Column() {
      // èƒŒæ™¯é®ç½©
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor('#66000000')
        .onClick(() => {
          this.showAboutDialog = false;
        })
    }
    .width('100%')
    .height('100%')
    .position({ x: 0, y: 0 })
    .zIndex(100)
    
    // å¯¹è¯æ¡†
    Column() {
      // Logo
      Image($r('app.media.vplus'))
        .width(80)
        .height(80)
        .borderRadius(16)
        .objectFit(ImageFit.Cover)
        .margin({ bottom: AppSpacing.Medium })
      
      // åº”ç”¨åç§°
      Text('Moonlight V+')
        .fontSize(AppSizes.FontLargeTitle)
        .fontWeight(FontWeight.Bold)
        .fontColor(AppColors.Primary)
        .margin({ bottom: AppSpacing.Small })
      
      // ç‰ˆæœ¬ä¿¡æ¯
      Text(this.getVersionInfo())
        .fontSize(AppSizes.FontBody)
        .fontColor(AppColors.TextSecondary)
        .margin({ bottom: AppSpacing.Large })
      
      // æè¿°
      Text('å¼€æºæ¸¸æˆä¸²æµå®¢æˆ·ç«¯ï¼ŒåŸºäº Moonlight å¼€å‘')
        .fontSize(AppSizes.FontBody)
        .fontColor(AppColors.TextSecondary)
        .textAlign(TextAlign.Center)
        .margin({ bottom: AppSpacing.Small })
        
      Text('æ”¯æŒ NVIDIA GeForce Experience å’Œ Sunshine')
        .fontSize(AppSizes.FontCaption)
        .fontColor(AppColors.TextTertiary)
        .textAlign(TextAlign.Center)
        .margin({ bottom: AppSpacing.XLarge })
      
      // æŒ‰é’®ç»„
      Row() {
        Button('GitHub')
          .height(40)
          .fontSize(AppSizes.FontBody)
          .fontColor(Color.White)
          .backgroundColor('#24292e')
          .borderRadius(AppSizes.RadiusMedium)
          .layoutWeight(1)
          .onClick(() => {
            this.openUrl('https://github.com/qiin2333/moonlight-vplus');
          })
        
        Button('åŠ å…¥QQç¾¤')
          .height(40)
          .fontSize(AppSizes.FontBody)
          .fontColor(Color.White)
          .backgroundColor('#12B7F5')
          .borderRadius(AppSizes.RadiusMedium)
          .layoutWeight(1)
          .margin({ left: AppSpacing.Medium })
          .onClick(() => {
            this.joinQQGroup('MeQFXB4ZoznvRzz7q_38LTmW5HrcfzcL');
          })
      }
      .width('100%')
      .margin({ bottom: AppSpacing.Medium })
      
      // å…³é—­æŒ‰é’®
      Button('å…³é—­')
        .width('100%')
        .height(44)
        .fontSize(AppSizes.FontBody)
        .fontColor(AppColors.TextSecondary)
        .backgroundColor(Color.Transparent)
        .onClick(() => {
          this.showAboutDialog = false;
        })
    }
    .width('85%')
    .padding(AppSpacing.XLarge)
    .backgroundColor(AppColors.Surface)
    .borderRadius(AppSizes.RadiusXLarge)
    .alignItems(HorizontalAlign.Center)
    .position({ x: '7.5%', y: '20%' })
    .zIndex(101)
  }

  // ==================== ä¸šåŠ¡é€»è¾‘ ====================
  
  /**
   * è·å–ç‰ˆæœ¬ä¿¡æ¯
   */
  private getVersionInfo(): string {
    try {
      const bundleInfo = bundleManager.getBundleInfoForSelfSync(bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION);
      const versionName = bundleInfo.versionName;
      const versionCode = bundleInfo.versionCode;
      return `ç‰ˆæœ¬ ${versionName} (Build ${versionCode})`;
    } catch (err) {
      console.error('è·å–ç‰ˆæœ¬ä¿¡æ¯å¤±è´¥', err);
      return 'ç‰ˆæœ¬æœªçŸ¥';
    }
  }
  
  /**
   * æ‰“å¼€ URL
   */
  private openUrl(url: string): void {
    try {
      const context = getContext(this) as common.UIAbilityContext;
      const want: Want = {
        action: 'ohos.want.action.viewData',
        uri: url
      };
      context.startAbility(want);
    } catch (err) {
      console.error('æ‰“å¼€ URL å¤±è´¥', err);
      promptAction.showToast({ message: 'æ— æ³•æ‰“å¼€é“¾æ¥' });
    }
  }
  
  /**
   * åŠ å…¥ QQ ç¾¤
   */
  private joinQQGroup(key: string): void {
    try {
      const context = getContext(this) as common.UIAbilityContext;
      // å°è¯•ä½¿ç”¨ QQ çš„ URI scheme
      const qqUri = `mqqopensdkapi://bizAgent/qm/qr?url=http%3A%2F%2Fqm.qq.com%2Fcgi-bin%2Fqm%2Fqr%3Ffrom%3Dapp%26p%3Dandroid%26jump_from%3Dwebapi%26k%3D${key}`;
      const want: Want = {
        action: 'ohos.want.action.viewData',
        uri: qqUri
      };
      context.startAbility(want).catch((err: BusinessError) => {
        // å¦‚æœ QQ æœªå®‰è£…ï¼Œæ‰“å¼€ç½‘é¡µç‰ˆ
        console.info('QQ æœªå®‰è£…ï¼Œæ‰“å¼€ç½‘é¡µç‰ˆ', err);
        this.openUrl('https://qm.qq.com/cgi-bin/qm/qr?k=' + key);
      });
    } catch (err) {
      console.error('åŠ å…¥ QQ ç¾¤å¤±è´¥', err);
      promptAction.showToast({ message: 'æ— æ³•æ‰“å¼€ QQ' });
    }
  }
  
  private async refreshComputers(): Promise<void> {
    this.isRefreshing = true;
    try {
      await this.computerManager.refreshAllComputers();
      this.syncViewModelFromManager();
    } catch (err) {
      console.error('åˆ·æ–°å¤±è´¥', err);
    } finally {
      this.isRefreshing = false;
    }
  }

  private async scanNetwork(): Promise<void> {
    this.isScanning = true;
    try {
      await this.computerManager.scanNetwork();
      this.syncViewModelFromManager();
      promptAction.showToast({ message: 'æ‰«æå®Œæˆ' });
    } catch (err) {
      console.error('æ‰«æå¤±è´¥', err);
      promptAction.showToast({ message: 'æ‰«æå¤±è´¥' });
    } finally {
      this.isScanning = false;
    }
  }

  private handleComputerTap(computer: ObservableComputer): void {
    // ç¦»çº¿ -> æ˜¾ç¤ºèœå•
    if (!computer.isOnline) {
      this.showComputerMenu(computer);
      return;
    }
    
    // å·²é…å¯¹ -> è¿›å…¥åº”ç”¨åˆ—è¡¨
    if (computer.isPaired) {
      router.pushUrl({
        url: 'pages/AppListPageV2',
        params: { computerId: computer.uuid }
      });
      return;
    }
    
    // åœ¨çº¿æœªé…å¯¹ -> é…å¯¹
    this.pairWithComputer(computer);
  }

  /**
   * å¿«é€Ÿä¸²æµå¤„ç†
   * ç‚¹å‡»å¿«é€Ÿä¸²æµæŒ‰é’®æ—¶ï¼š
   * 1. å¦‚æœæœ‰æ­£åœ¨è¿è¡Œçš„æ¸¸æˆï¼Œæ¢å¤è¯¥æ¸¸æˆ
   * 2. å¦åˆ™è·å–åº”ç”¨åˆ—è¡¨ï¼Œå¯åŠ¨ç¬¬ä¸€ä¸ªåº”ç”¨
   */
  private async handleQuickStream(computer: ObservableComputer): Promise<void> {
    if (!computer.isOnline || !computer.isPaired) {
      promptAction.showToast({ message: 'è®¾å¤‡æœªå°±ç»ª' });
      return;
    }

    try {
      // æ˜¾ç¤ºåŠ è½½æç¤º
      promptAction.showToast({ message: 'æ­£åœ¨å‡†å¤‡ä¸²æµ...', duration: 1000 });

      // è·å–å®Œæ•´ç”µè„‘ä¿¡æ¯ï¼ˆåŒ…å« serverCertï¼‰
      const computerInfo = this.computerManager.getComputer(computer.uuid);
      if (!computerInfo || computerInfo.pairState !== PairState.PAIRED) {
        promptAction.showToast({ message: 'è®¾å¤‡æœªé…å¯¹' });
        return;
      }

      // å¦‚æœæœ‰æ­£åœ¨è¿è¡Œçš„æ¸¸æˆï¼Œç›´æ¥æ¢å¤
      if (computer.runningGameId > 0) {
        console.info(`PcListPageV2: å¿«é€Ÿæ¢å¤æ¸¸æˆ ID=${computer.runningGameId}`);
        router.pushUrl({
          url: 'pages/StreamPage',
          params: {
            computerId: computer.uuid,
            appId: computer.runningGameId,
            appName: 'æ­£åœ¨è¿è¡Œ',  // å ä½ï¼Œå®é™…ä¼šä»æœåŠ¡å™¨è·å–
            resume: true
          }
        });
        return;
      }

      // è·å–åº”ç”¨åˆ—è¡¨
      const context = getContext(this) as common.UIAbilityContext;
      const nvHttp = new NvHttp(computerInfo.address, computerInfo.serverCert, context, computerInfo.httpPort);
      const apps = await nvHttp.getAppList();

      if (apps.length === 0) {
        promptAction.showToast({ message: 'æ²¡æœ‰å¯ç”¨çš„åº”ç”¨' });
        return;
      }

      // å¯åŠ¨ç¬¬ä¸€ä¸ªåº”ç”¨
      const firstApp = apps[0];
      console.info(`PcListPageV2: å¿«é€Ÿå¯åŠ¨åº”ç”¨ ${firstApp.name} (ID=${firstApp.id})`);
      router.pushUrl({
        url: 'pages/StreamPage',
        params: {
          computerId: computer.uuid,
          appId: firstApp.id,
          appName: firstApp.name,
          resume: false
        }
      });
    } catch (err) {
      console.error(`PcListPageV2: å¿«é€Ÿä¸²æµå¤±è´¥`, err);
      promptAction.showToast({ message: `å¯åŠ¨å¤±è´¥: ${(err as Error).message}` });
    }
  }

  private async pairWithComputer(computer: ObservableComputer): Promise<void> {
    // æ£€æŸ¥æ˜¯å¦åœ¨çº¿
    if (!computer.isOnline) {
      promptAction.showToast({ message: 'ç”µè„‘ç¦»çº¿ï¼Œæ— æ³•é…å¯¹' });
      return;
    }

    // ç”ŸæˆPINç 
    const pin = PairingManager.generatePin();
    this.currentPin = pin;
    this.pairingComputerName = computer.name;
    this.showPinDialog = true;

    try {
      console.info(`PcListPageV2: å¼€å§‹é…å¯¹ ${computer.name}, PIN: ${pin}, httpPort: ${computer.httpPort}`);

      // æ‰§è¡Œé…å¯¹ï¼ˆä½¿ç”¨ä¿å­˜çš„è‡ªå®šä¹‰ç«¯å£ï¼‰
      const context = getContext(this) as common.UIAbilityContext;
      const pairingManager = new PairingManager(computer.address, computer.uuid, context, computer.httpPort);
      const result = await pairingManager.pair(pin);

      console.info(`PcListPageV2: é…å¯¹ç»“æœ ${result.state}`);
      this.showPinDialog = false;

      if (result.state === PMPairState.PAIRED) {
        // ä½¿ç”¨ updateComputer æ–¹æ³•æ›´æ–°åŸå§‹ç”µè„‘æ•°æ®
        let serverCertBase64 = '';
        if (result.serverCert) {
          const buf = buffer.from(result.serverCert);
          serverCertBase64 = buf.toString('base64');
        }
        
        await this.computerManager.updateComputer(computer.uuid, {
          pairState: PairState.PAIRED,
          serverCert: serverCertBase64,
          pairName: result.pairName || ''
        });
        
        console.info(`PcListPageV2: é…å¯¹æˆåŠŸï¼ŒserverCert é•¿åº¦: ${serverCertBase64.length}`);
        
        // åˆ·æ–°åˆ—è¡¨
        await this.syncViewModelFromManager();

        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
        promptAction.showToast({ message: 'é…å¯¹æˆåŠŸï¼' });

        // è‡ªåŠ¨è¿›å…¥åº”ç”¨åˆ—è¡¨
        router.pushUrl({
          url: 'pages/AppListPageV2',
          params: { computerId: computer.uuid }
        });
      } else if (result.state === PMPairState.PIN_WRONG) {
        promptAction.showToast({ message: 'PIN ç é”™è¯¯ï¼Œè¯·é‡è¯•' });
      } else if (result.state === PMPairState.ALREADY_IN_PROGRESS) {
        promptAction.showToast({ message: 'å¦ä¸€ä¸ªè®¾å¤‡æ­£åœ¨é…å¯¹ä¸­' });
      } else {
        promptAction.showToast({ message: `é…å¯¹å¤±è´¥: ${result.state}` });
      }
    } catch (error) {
      const err = error as Error;
      this.showPinDialog = false;
      console.error('PcListPageV2: é…å¯¹å¼‚å¸¸', err);
      promptAction.showToast({ message: `é…å¯¹å¤±è´¥: ${err.message}` });
    }
  }

  private showComputerMenu(computer: ObservableComputer): void {
    const options: OptionItem[] = [];
    const actionMap = new Map<string, () => void>();
    let actionIndex = 0;
    
    if (!computer.isOnline) {
      const key = `action_${actionIndex++}`;
      actionMap.set(key, () => this.wakeComputer(computer));
      options.push({
        title: 'å‘é€å”¤é†’åŒ… (WOL)',
        subtitle: 'å°è¯•é€šè¿‡ç½‘ç»œå”¤é†’ç”µè„‘',
        value: key
      });
    } else if (!computer.isPaired) {
      const key = `action_${actionIndex++}`;
      actionMap.set(key, () => this.pairWithComputer(computer));
      options.push({
        title: 'é…å¯¹',
        subtitle: 'ä¸ç”µè„‘å»ºç«‹å®‰å…¨è¿æ¥',
        value: key
      });
    } else {
      if (computer.isGaming) {
        const resumeKey = `action_${actionIndex++}`;
        actionMap.set(resumeKey, () => this.resumeGame(computer));
        options.push({
          title: 'æ¢å¤æ¸¸æˆ',
          subtitle: 'ç»§ç»­ä¹‹å‰çš„æ¸¸æˆä¼šè¯',
          value: resumeKey
        });
        
        const quitKey = `action_${actionIndex++}`;
        actionMap.set(quitKey, () => this.quitGame(computer));
        options.push({
          title: 'é€€å‡ºæ¸¸æˆ',
          subtitle: 'ç»“æŸå½“å‰è¿è¡Œçš„æ¸¸æˆ',
          value: quitKey
        });
      }
      
      const appListKey = `action_${actionIndex++}`;
      actionMap.set(appListKey, () => router.pushUrl({
        url: 'pages/AppListPageV2',
        params: { computerId: computer.uuid }
      }));
      options.push({
        title: 'åº”ç”¨åˆ—è¡¨',
        subtitle: 'æŸ¥çœ‹å¯ä¸²æµçš„åº”ç”¨',
        value: appListKey
      });
      
      const unpairKey = `action_${actionIndex++}`;
      actionMap.set(unpairKey, () => this.unpairComputer(computer));
      options.push({
        title: 'å–æ¶ˆé…å¯¹',
        subtitle: 'æ–­å¼€ä¸ç”µè„‘çš„é…å¯¹',
        value: unpairKey
      });
      
      const sleepKey = `action_${actionIndex++}`;
      actionMap.set(sleepKey, () => this.sleepComputer(computer));
      options.push({
        title: 'ä¼‘çœ ç”µè„‘',
        subtitle: 'è®©ç”µè„‘è¿›å…¥ä¼‘çœ çŠ¶æ€',
        value: sleepKey
      });
    }
    
    const networkKey = `action_${actionIndex++}`;
    actionMap.set(networkKey, () => this.testNetwork(computer));
    options.push({
      title: 'ç½‘ç»œæµ‹è¯•',
      subtitle: 'æµ‹è¯•ä¸ç”µè„‘çš„ç½‘ç»œè¿æ¥',
      value: networkKey
    });
    
    const detailsKey = `action_${actionIndex++}`;
    actionMap.set(detailsKey, () => this.showComputerDetails(computer));
    options.push({
      title: 'æŸ¥çœ‹è¯¦æƒ…',
      subtitle: 'æ˜¾ç¤ºç”µè„‘çš„è¯¦ç»†ä¿¡æ¯',
      value: detailsKey
    });
    
    const deleteKey = `action_${actionIndex++}`;
    actionMap.set(deleteKey, () => this.deleteComputer(computer));
    options.push({
      title: 'åˆ é™¤ç”µè„‘',
      subtitle: 'ä»åˆ—è¡¨ä¸­ç§»é™¤æ­¤ç”µè„‘',
      value: deleteKey
    });

    // è®¾ç½®é…ç½®
    this.optionPickerDialogConfig = {
      title: computer.name,
      subtitle: computer.statusText,
      options: options,
      selectedValue: '',
      onSelect: (option: OptionItem) => {
        const action = actionMap.get(option.value as string);
        if (action) {
          action();
        }
      }
    };
    
    // åˆ›å»ºå¹¶æ‰“å¼€å¼¹çª—
    this.optionPickerDialogController = new CustomDialogController({
      builder: OptionPickerDialog({
        config: this.optionPickerDialogConfig
      }),
      alignment: DialogAlignment.Bottom,
      customStyle: true,
      backgroundColor: Color.Transparent
    });
    this.optionPickerDialogController.open();
  }

  private async wakeComputer(computer: ObservableComputer): Promise<void> {
    console.info(`PcListPageV2: wakeComputer è¢«è°ƒç”¨ - ${computer.name}, MAC: ${computer.macAddress}`);
    
    if (!computer.macAddress || computer.macAddress === '00:00:00:00:00:00') {
      console.warn(`PcListPageV2: ${computer.name} ç¼ºå°‘æœ‰æ•ˆçš„ MAC åœ°å€`);
      promptAction.showToast({ message: 'ç¼ºå°‘æœ‰æ•ˆçš„ MAC åœ°å€ã€‚è¯·å…ˆåœ¨ç”µè„‘åœ¨çº¿æ—¶é…å¯¹ï¼Œä»¥è·å– MAC åœ°å€ã€‚' });
      return;
    }
    
    try {
      console.info(`PcListPageV2: æ­£åœ¨å‘é€ WOL å”¤é†’åŒ…...`);
      await this.computerManager.wakeComputer(computer.uuid);
      console.info(`PcListPageV2: WOL å”¤é†’åŒ…å·²å‘é€æˆåŠŸ`);
      promptAction.showToast({ message: 'å”¤é†’åŒ…å·²å‘é€' });
    } catch (err) {
      console.error(`PcListPageV2: WOL å‘é€å¤±è´¥:`, err);
      const errMessage = err instanceof Error ? err.message : String(err);
      promptAction.showToast({ message: `å‘é€å¤±è´¥: ${errMessage}` });
    }
  }

  private async quitGame(computer: ObservableComputer): Promise<void> {
    if (!computer.isOnline) {
      const toastOpts: promptAction.ShowToastOptions = { message: 'ç”µè„‘ç¦»çº¿ï¼Œæ— æ³•é€€å‡ºæ¸¸æˆ' };
      promptAction.showToast(toastOpts);
      return;
    }

    if (!computer.isPaired) {
      const toastOpts: promptAction.ShowToastOptions = { message: 'æœªé…å¯¹ï¼Œæ— æ³•é€€å‡ºæ¸¸æˆ' };
      promptAction.showToast(toastOpts);
      return;
    }

    if (!computer.runningGameId || computer.runningGameId <= 0) {
      const toastOpts: promptAction.ShowToastOptions = { message: 'æ²¡æœ‰æ­£åœ¨è¿è¡Œçš„æ¸¸æˆ' };
      promptAction.showToast(toastOpts);
      return;
    }

    this.showConfirmDialog({
      title: 'é€€å‡ºæ¸¸æˆ',
      message: 'ç¡®å®šè¦é€€å‡ºå½“å‰è¿è¡Œçš„æ¸¸æˆå—ï¼Ÿ',
      confirmButton: {
        text: 'é€€å‡º',
        color: AppColors.Error,
        onClick: async () => {
          try {
            const toastOptions: promptAction.ShowToastOptions = { message: 'æ­£åœ¨é€€å‡ºæ¸¸æˆ...' };
            promptAction.showToast(toastOptions);

            const context = getContext(this) as common.UIAbilityContext;
            const nvHttp = new NvHttp(computer.address, computer.serverCert || null, context, computer.httpPort);
            const success = await nvHttp.quitApp();

            if (success) {
              const successToast: promptAction.ShowToastOptions = { message: 'æ¸¸æˆå·²é€€å‡º' };
              promptAction.showToast(successToast);
              await this.computerManager.pollComputer(computer.toComputerInfo());
              await this.syncViewModelFromManager();
            } else {
              const failToast: promptAction.ShowToastOptions = { message: 'é€€å‡ºæ¸¸æˆå¤±è´¥' };
              promptAction.showToast(failToast);
            }
          } catch (error) {
            const err = error as Error;
            const errorToast: promptAction.ShowToastOptions = { message: `é€€å‡ºæ¸¸æˆå¤±è´¥: ${err.message}` };
            promptAction.showToast(errorToast);
          }
        }
      }
    });
  }

  private async sleepComputer(computer: ObservableComputer): Promise<void> {
    if (!computer.isOnline) {
      const toastOpts: promptAction.ShowToastOptions = { message: 'ç”µè„‘ç¦»çº¿ï¼Œæ— æ³•ä¼‘çœ ' };
      promptAction.showToast(toastOpts);
      return;
    }

    if (!computer.isPaired) {
      const toastOpts: promptAction.ShowToastOptions = { message: 'æœªé…å¯¹ï¼Œæ— æ³•å‘é€ä¼‘çœ å‘½ä»¤' };
      promptAction.showToast(toastOpts);
      return;
    }

    this.showConfirmDialog({
      title: 'ä¼‘çœ ç”µè„‘',
      message: `ç¡®å®šè¦è®© "${computer.name}" è¿›å…¥ç¡çœ æ¨¡å¼å—ï¼Ÿ`,
      confirmButton: {
        text: 'ä¼‘çœ ',
        onClick: async () => {
          try {
            const toastOpts: promptAction.ShowToastOptions = { message: 'æ­£åœ¨å‘é€ä¼‘çœ å‘½ä»¤...' };
            promptAction.showToast(toastOpts);

            const context = getContext(this) as common.UIAbilityContext;
            const nvHttp = new NvHttp(computer.address, computer.serverCert || null, context, computer.httpPort);
            const success = await nvHttp.pcSleep();

            if (success) {
              promptAction.showToast({ message: 'ç¡çœ å‘½ä»¤å·²å‘é€' });
              // ç”µè„‘å°†è¿›å…¥ç¡çœ ï¼Œå…ˆæœ¬åœ°æ ‡è®°ä¸ºç¦»çº¿ï¼Œå†åˆ·æ–°åˆ—è¡¨
              computer.state = ComputerState.OFFLINE;
              await this.syncViewModelFromManager();
            } else {
              promptAction.showToast({ message: 'å‘é€ç¡çœ å‘½ä»¤å¤±è´¥' });
            }
          } catch (error) {
            const err = error as Error;
            promptAction.showToast({ message: `å‘é€ç¡çœ å‘½ä»¤å¤±è´¥: ${err.message}` });
          }
        }
      }
    });
  }

  private resumeGame(computer: ObservableComputer): void {
    router.pushUrl({
      url: 'pages/StreamPage',
      params: {
        computerId: computer.uuid,
        appId: computer.runningGameId,
        resume: true
      }
    });
  }

  private async unpairComputer(computer: ObservableComputer): Promise<void> {
    this.showConfirmDialog({
      title: 'å–æ¶ˆé…å¯¹',
      message: `ç¡®å®šè¦å–æ¶ˆä¸ ${computer.name} çš„é…å¯¹å—ï¼Ÿ`,
      confirmButton: {
        text: 'ç¡®å®š',
        color: AppColors.Error,
        onClick: async () => {
          try {
            await this.computerManager.unpairComputer(computer.uuid);
            promptAction.showToast({ message: 'å·²å–æ¶ˆé…å¯¹' });
            this.syncViewModelFromManager();
          } catch (err) {
            promptAction.showToast({ message: 'æ“ä½œå¤±è´¥' });
          }
        }
      }
    });
  }

  private async deleteComputer(computer: ObservableComputer): Promise<void> {
    this.showConfirmDialog({
      title: 'åˆ é™¤ç”µè„‘',
      message: `ç¡®å®šè¦åˆ é™¤ ${computer.name} å—ï¼Ÿ`,
      confirmButton: {
        text: 'åˆ é™¤',
        color: AppColors.Error,
        onClick: async () => {
          try {
            await this.computerManager.removeComputer(computer.uuid);
            promptAction.showToast({ message: 'å·²åˆ é™¤' });
            this.syncViewModelFromManager();
          } catch (err) {
            promptAction.showToast({ message: 'åˆ é™¤å¤±è´¥' });
          }
        }
      }
    });
  }

  private async testNetwork(computer: ObservableComputer): Promise<void> {
    promptAction.showToast({ message: 'æ­£åœ¨æµ‹è¯•ç½‘ç»œ...' });
    
    try {
      // ç®€å•åœ°å°è¯• poll ç”µè„‘è·å–çŠ¶æ€
      const computerInfo = computer.toComputerInfo();
      await this.computerManager.pollComputer(computerInfo);
      
      this.showInfoDialog({
        title: 'ç½‘ç»œæµ‹è¯•ç»“æœ',
        content: `ç”µè„‘ ${computer.name} å“åº”æ­£å¸¸`
      });
    } catch (error) {
      const err = error as Error;
      this.showInfoDialog({
        title: 'ç½‘ç»œæµ‹è¯•ç»“æœ',
        content: `ç”µè„‘ ${computer.name} æ— æ³•è¿æ¥\n${err.message}`
      });
    }
  }

  private showComputerDetails(computer: ObservableComputer): void {
    const stateText = computer.isOnline ? 'åœ¨çº¿' : 'ç¦»çº¿';
    const pairText = computer.isPaired ? 'å·²é…å¯¹' : 'æœªé…å¯¹';
    const gamingText = computer.isGaming ? `æ­£åœ¨è¿è¡Œæ¸¸æˆ (ID: ${computer.runningGameId})` : 'ç©ºé—²';
    
    // æ„å»ºåœ°å€ä¿¡æ¯ï¼ˆæ˜¾ç¤ºæ‰€æœ‰ç±»å‹ï¼‰
    const addressLines: string[] = [];
    const info = computer.toComputerInfo();
    if (info.manualAddress) {
      addressLines.push(`æ‰‹åŠ¨åœ°å€: ${info.manualAddress}`);
    }
    if (info.localAddress) {
      addressLines.push(`æœ¬åœ°åœ°å€: ${info.localAddress}`);
    }
    if (info.remoteAddress) {
      addressLines.push(`è¿œç¨‹åœ°å€: ${info.remoteAddress}`);
    }
    if (info.address && info.address !== info.localAddress && info.address !== info.remoteAddress && info.address !== info.manualAddress) {
      addressLines.push(`å½“å‰åœ°å€: ${info.address}`);
    }
    if (addressLines.length === 0) {
      addressLines.push(`åœ°å€: æœªçŸ¥`);
    }
    
    const details = [
      `åç§°: ${computer.name}`,
      `çŠ¶æ€: ${stateText}`,
      `é…å¯¹: ${pairText}`,
      `æ¸¸æˆ: ${gamingText}`,
      ``,
      `UUID: ${computer.uuid}`,
      ...addressLines,
      `MAC åœ°å€: ${computer.macAddress || 'æœªçŸ¥'}`,
      `HTTPS ç«¯å£: ${NvHttp.DEFAULT_HTTPS_PORT}`,
      `HTTP ç«¯å£: ${info.httpPort || NvHttp.DEFAULT_HTTP_PORT}`,
    ].join('\n');
    
    this.showInfoDialog({
      title: computer.name,
      content: details
    });
  }
}
